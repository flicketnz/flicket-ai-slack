# Snowflake SQL Execution Implementation Design

## Overview

This document outlines the design for implementing SQL statement execution against Snowflake within the existing [`SnowflakeCortexAgentAdapter`](../packages/nestjs/src/modules/domains/ai/modules/snowflake-agent/adapters/snowflake-cortex.agent.ts). The implementation will use Snowflake's SQL REST API v2 for synchronous execution of SQL statements generated by the Cortex agent.

## Current Architecture Analysis

### Existing Components

- **SnowflakeCortexAgentAdapter**: LangGraph-based agent with JWT authentication
- **SnowflakeJwtService**: Handles JWT token generation and validation
- **HttpService**: Pre-configured with Snowflake endpoint and auth interceptors
- **Three-node workflow**: Only `cortexAnalystNode` currently implemented

### State Management

Current state tracks:
- `messages`: LangChain BaseMessage array
- `sql`: Extracted SQL statement from Cortex response

## 1. Snowflake SQL REST API v2 Analysis

### Endpoint
- **URL**: `/api/v2/statements`
- **Method**: POST
- **Authentication**: JWT Bearer token (already implemented)

### Request Format
```typescript
interface SnowflakeSQLRequest {
  statement: string;              // Required: SQL statement to execute
  timeout?: number;               // Optional: Query timeout in seconds (default: 60)
  database?: string;              // Optional: Database context
  schema?: string;                // Optional: Schema context  
  warehouse?: string;             // Optional: Warehouse to use
  role?: string;                  // Optional: Role to assume
  bindings?: Record<string, any>; // Optional: Parameter bindings for prepared statements
  parameters?: {                  // Optional: Session parameters
    QUERY_TAG?: string;
    BINARY_OUTPUT_FORMAT?: string;
  };
}
```

### Response Format
```typescript
interface SnowflakeSQLResponse {
  resultSetMetaData: {
    numRows: number;              // Total number of rows
    format: string;               // Result format (usually "json")
    partitionInfo?: any[];        // Partition information for large results
    rowType: Array<{              // Column metadata
      name: string;               // Column name
      type: string;               // Snowflake data type
      length?: number;            // For string types
      precision?: number;         // For numeric types
      scale?: number;             // For numeric types
      nullable: boolean;          // Whether column allows NULL
    }>;
  };
  data: any[][];                  // Result data as 2D array
  code: string;                   // Response code (usually "090001" for success)
  message: string;                // Response message
  success: boolean;               // Whether execution succeeded
  statementHandle?: string;       // Handle for statement tracking
  createdOn: number;              // Timestamp of execution
  statementStatusUrl?: string;    // URL for checking statement status
}
```

### Error Response Format
```typescript
interface SnowflakeErrorResponse {
  code: string;                   // Error code (e.g., "000904" for syntax error)
  message: string;                // Error description
  success: false;
  sqlState?: string;              // SQL state code
  statementHandle?: string;
}
```

## 2. Enhanced Agent State Design

```typescript
private stateDefinition = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {
      if (Array.isArray(right)) {
        return left.concat(right);
      }
      return left.concat([right]);
    },
    default: () => [],
  }),
  sql: Annotation<Extract<SnowflakeCortexResponse["message"]["content"][number], { type: "sql" }>>,
  sqlResults: Annotation<{
    data: any[][];
    metadata: SnowflakeSQLResponse['resultSetMetaData'];
    executionTime: number;
    rowCount: number;
    formattedResults?: string;     // Human-readable format
    success: boolean;
    error?: string;
  }>,
  tenantContext: Annotation<{
    tenantId?: string;
    userId?: string;
    segmentationApplied: boolean;
    allowedTables?: string[];
  }>,
});
```

## 3. SQL Execution Service Interface

```typescript
export interface SQLExecutionOptions {
  timeout?: number;               // Query timeout (default: 30s)
  database?: string;              // Target database
  schema?: string;                // Target schema
  warehouse?: string;             // Compute warehouse
  maxRows?: number;               // Result limit (default: 1000)
  tenantContext?: TenantContext;  // For data isolation
}

export interface TenantContext {
  tenantId: string;
  userId: string;
  allowedTables?: string[];
  additionalFilters?: Record<string, any>;
}

export interface FormattedSQLResults {
  tableFormat: string;            // ASCII table format
  summaryText: string;            // Natural language summary
  chartData?: any;                // Data suitable for visualization
  insights?: string[];            // Generated insights
}

@Injectable()
export class SnowflakeSQLExecutionService {
  constructor(
    private readonly httpService: HttpService,
    private readonly logger: Logger,
    @Inject(agentSnowflakeCortexConfig.KEY) 
    private readonly config: ConfigType<typeof agentSnowflakeCortexConfig>
  ) {}

  async executeSQL(
    statement: string,
    options: SQLExecutionOptions = {}
  ): Promise<SnowflakeSQLResponse>;

  async executeWithTenantIsolation(
    statement: string,
    tenantContext: TenantContext,
    options: SQLExecutionOptions = {}
  ): Promise<SnowflakeSQLResponse>;

  private addTenantSegmentation(
    statement: string, 
    tenantContext: TenantContext
  ): string;

  private validateSQL(statement: string): void;

  private formatResults(response: SnowflakeSQLResponse): FormattedSQLResults;
}
```

## 4. Node Implementations

### addTenantSegmentationNode

**Purpose**: Modify SQL statements to ensure tenant data isolation

**Logic**:
1. Parse SQL AST to identify table references
2. Validate table access permissions
3. Add tenant-specific WHERE clauses
4. Ensure no unauthorized operations (DDL, etc.)

**Example Transformation**:
```sql
-- Original from Cortex
SELECT event_name, COUNT(*) FROM events GROUP BY event_name;

-- After tenant segmentation
SELECT event_name, COUNT(*) 
FROM events 
WHERE tenant_id = 'tenant_123' 
  AND (promoter_id = 'user_456' OR public_event = true)
GROUP BY event_name;
```

**Security Validations**:
- Block DDL operations (CREATE, DROP, ALTER)
- Whitelist allowed functions
- Prevent access to system tables
- Validate table permissions

### executeSnowflakeSQLNode

**Purpose**: Execute segmented SQL and format results

**Logic**:
1. Execute SQL via Snowflake SQL REST API v2
2. Handle timeouts and retries
3. Format results for presentation
4. Generate insights and summaries

**Error Handling**:
- Syntax errors → User-friendly explanation
- Permission errors → Generic access denied
- Timeout errors → Optimization suggestions
- Resource errors → Retry with backoff

## 5. Security Implementation

### SQL Injection Prevention
```typescript
private validateSQL(statement: string): void {
  // 1. Parse SQL using a SQL parser library
  // 2. Validate allowed operations (SELECT only)
  // 3. Check for dangerous patterns
  // 4. Validate table/column references
  
  const dangerousPatterns = [
    /;\s*(DROP|CREATE|ALTER|DELETE|UPDATE|INSERT)/i,
    /EXEC\s*\(/i,
    /xp_cmdshell/i,
    /sp_executesql/i
  ];
  
  for (const pattern of dangerousPatterns) {
    if (pattern.test(statement)) {
      throw new Error('Unauthorized SQL operation detected');
    }
  }
}
```

### Tenant Isolation Strategy
```typescript
private addTenantSegmentation(statement: string, context: TenantContext): string {
  // 1. Parse SQL to identify FROM/JOIN clauses
  // 2. Add WHERE conditions for each table
  // 3. Maintain query semantics while adding filters
  
  const tenantFilters = {
    events: `tenant_id = '${context.tenantId}'`,
    users: `tenant_id = '${context.tenantId}'`,
    bookings: `tenant_id = '${context.tenantId}' AND user_id = '${context.userId}'`
  };
  
  // Implementation would use SQL AST manipulation
  return modifiedStatement;
}
```

## 6. Response Integration

### Enhanced Message Conversion
```typescript
private convertResponseToMessages(
  response: SnowflakeCortexResponse,
  sqlResults?: SQLExecutionResults
): BaseMessage[] {
  const messages: BaseMessage[] = [];
  
  // Original Cortex response
  if (response.message.content) {
    const textContent = response.message.content
      .filter(item => item.type === 'text')
      .map(item => item.text)
      .join('\n');
    
    // SQL execution results
    let finalContent = textContent;
    if (sqlResults?.success) {
      finalContent += '\n\n**Query Results:**\n';
      finalContent += sqlResults.formattedResults.tableFormat;
      finalContent += `\n\n*Found ${sqlResults.rowCount} rows*`;
      
      if (sqlResults.formattedResults.insights?.length) {
        finalContent += '\n\n**Insights:**\n';
        finalContent += sqlResults.formattedResults.insights.join('\n- ');
      }
    } else if (sqlResults?.error) {
      finalContent += `\n\n⚠️ **Query Error:** ${sqlResults.error}`;
    }
    
    messages.push(new AIMessage({
      content: finalContent,
      response_metadata: {
        ...response.response_metadata,
        sql_execution: sqlResults
      },
      additional_kwargs: {
        source_agent: this.agentId,
        sql_results: sqlResults
      }
    }));
  }
  
  return messages;
}
```

## 7. Configuration Schema

```typescript
interface SQLExecutionConfig {
  enabled: boolean;                    // Enable SQL execution
  maxExecutionTime: number;            // 30 seconds default
  maxResultRows: number;               // 1000 rows default
  allowedTables: string[];             // Whitelist of accessible tables
  enableTenantSegmentation: boolean;   // Enable tenant isolation
  defaultDatabase: string;             // Default database context
  defaultSchema: string;               // Default schema context
  defaultWarehouse: string;            // Default warehouse
  retryAttempts: number;               // Retry attempts for failures
  retryDelay: number;                  // Delay between retries (ms)
}
```

## 8. Monitoring and Observability

### Metrics to Track
- SQL execution duration
- Result set sizes
- Error rates by category
- Tenant segmentation effectiveness
- Query complexity patterns

### Logging Strategy
```typescript
// Before execution
this.logger.log(`Executing SQL for tenant ${tenantId}`, {
  tenantId,
  userId,
  sqlHash: hashSQL(statement), // Don't log actual SQL for security
  segmentationApplied: true
});

// After execution
this.logger.log(`SQL execution completed`, {
  tenantId,
  duration: executionTime,
  rowCount: results.length,
  success: true
});
```

### Error Alerting
- Failed tenant segmentation attempts
- Unauthorized table access attempts
- Execution timeouts exceeding thresholds
- Unusual query patterns

## 9. Implementation Timeline

1. **Phase 1**: SQL Execution Service
   - Create service interface and basic implementation
   - Implement Snowflake API integration
   - Add basic error handling

2. **Phase 2**: Security Layer
   - Implement SQL validation
   - Add tenant segmentation logic
   - Create security tests

3. **Phase 3**: Agent Integration
   - Update agent state definition
   - Implement node logic
   - Update response formatting

4. **Phase 4**: Monitoring & Testing
   - Add comprehensive logging
   - Implement metrics collection
   - Create integration tests

## 10. Testing Strategy

### Unit Tests
- SQL validation logic
- Tenant segmentation transformations
- Result formatting functions
- Error handling scenarios

### Integration Tests
- End-to-end agent workflow
- Snowflake API integration
- Authentication and authorization
- Performance under load

### Security Tests
- SQL injection attempts
- Unauthorized table access
- Tenant isolation verification
- Permission boundary testing

This design provides a comprehensive foundation for implementing secure, tenant-aware SQL execution within the existing Snowflake Cortex agent architecture.